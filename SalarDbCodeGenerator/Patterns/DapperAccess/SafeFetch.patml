<?xml version="1.0" encoding="utf-8" ?>
<PatternFile>
    <Name>DapperAccess base</Name>
    <Description>DapperAccess base pattern</Description>
    <Options
		Group="Base"
		AppliesTo="General"
		Overwrite="true"
		FilePath="Base\SafeFetch.cs"
		Language="C#"
		/>
    <BaseContent>
        <![CDATA[using System;
using System.Collections.Generic;
using System.Configuration;
using System.Data;
using System.Linq;
using System.Text;
using System.Data.SqlClient;
using Dapper;
using System.Reflection;
using Npgsql;

namespace [:Namespace:].Base
{
    public enum SortDirection { Ascending, Descending };

    /// <summary>
    /// Static class that provides SQL-injection-proof queries and deletes for Dapper classes
    /// </summary>
    public class SafeFetch : ISafeQueryExecutor
    {
        private static readonly int DefaultDatabaseTimeout;
        private readonly IDbConnectionFactory _dbConnectionFactory;

        static SafeFetch()
        {
            string value = ConfigurationManager.AppSettings["DatabaseTimeout"];
            if (string.IsNullOrEmpty(value))
            {
                DefaultDatabaseTimeout = 60;
            }
            else
            {
                DefaultDatabaseTimeout = int.Parse(value);
            }
        }

        public SafeFetch(IDbConnectionFactory dbConnectionFactory)
        {
            _dbConnectionFactory = dbConnectionFactory;
        }

        public SafeFetchResults<T> SafeQuery<T>(string filter, string fieldsToLoad, string orderbyAndDirectionString,
            int startIndex, int maxResults, int? queryTimeout, string tableName)
        {
            return SafeQuery<T>(new DefaultSafeFetchQueryBuilder(), new DefaultDatabaseColumnTranslator(typeof(T)), filter, fieldsToLoad, orderbyAndDirectionString, startIndex, maxResults, queryTimeout, tableName);
        }

        public SafeFetchResults<T> SafeQuery<T>(ISafeFetchQueryBuilder builder, IDatabaseColumnTranslator databaseColumnTranslator, string filter, string fieldsToLoad, string orderbyAndDirectionString,
            int startIndex, int maxResults, int? queryTimeout, string tableName)
        {
            SafeFetchQuery query = ToSafeFetchQuery(databaseColumnTranslator ?? new DefaultDatabaseColumnTranslator(typeof(T)), filter, fieldsToLoad, tableName, orderbyAndDirectionString);

            return InternalSafeQuery<T>(builder ?? new DefaultSafeFetchQueryBuilder(), _dbConnectionFactory, query, startIndex, maxResults, queryTimeout);
        }

        public MultiSafeFetchResults<T1, T2, T3> SafeQuery<T1, T2, T3>(ISafeFetchQueryBuilder builder, IDatabaseColumnTranslator databaseColumnTranslator, string tableName, string filter, string fieldsToLoad, string orderbyAndDirectionString, int? queryTimeout)
        {
            SafeFetchQuery query = ToSafeFetchQuery(databaseColumnTranslator, filter, fieldsToLoad, tableName, orderbyAndDirectionString);

            if (builder == null)
                throw new ArgumentNullException("builder", "Must specify a ISafeFetchQueryBuilder");

            if (databaseColumnTranslator == null)
                throw new ArgumentNullException("databaseColumnTranslator", "Must specify a IDatabaseColumnTranslator");

            return SafeQuery<T1, T2, T3>(builder, _dbConnectionFactory, query, queryTimeout);
        }

        public long SafeDelete<T>(string filter, string tableName)
        {
            return InternalSafeDelete<T>(_dbConnectionFactory, filter, tableName);
        }

        public long Insert<T>(IDapWithInt64PrimaryKey<T> baseDap, T entity)
        {
            return baseDap.InsertWithId(entity);
        }

        public int Insert<T>(IDapWithInt32PrimaryKey<T> baseDap, T entity)
        {
            return baseDap.InsertWithId(entity);
        }

        public void Update<T>(IDap<T> dap, T entity)
        {
            dap.Update(entity);
        }

        private MultiSafeFetchResults<T1, T2, T3> SafeQuery<T1, T2, T3>(ISafeFetchQueryBuilder builder, IDbConnectionFactory dbConnectionFactory, SafeFetchQuery query, int? queryTimeout)
        {
            MultiSafeFetchResults<T1, T2, T3> results = new MultiSafeFetchResults<T1, T2, T3>();
            results.SortInfos = query.Sort;

            using(Dap dap = new Dap(dbConnectionFactory))
            {
                // First turn this filter into a safe list of values
                SafeFilterParser sfp = new SafeFilterParser();
                sfp.Parse(query.Filter, typeof(T1), query.Sort, GetDbType(dap.Connection));

                string fullQuery = builder.BuildSelectQuery(query.ToSelectString(), query.Table, sfp.Filter, sfp.OrderBy);

                if (dap.Connection.State != ConnectionState.Open)
                    dap.Connection.Open();

                // Now query the database and retrieve the object
                using (IDbTransaction trans = dap.Connection.BeginTransaction())
                {
                    var multi = dap.QueryMultiple(fullQuery, sfp.SqlParams, trans, queryTimeout ?? DefaultDatabaseTimeout, CommandType.Text);

                    results.FirstValues = multi.Read<T1>().ToList();
                    results.SecondValues = multi.Read<T2>().ToList();
                    results.ThirdValues = multi.Read<T3>().ToList();
                }
            }

            results.StartIndex = 0;
            results.EndIndex = results.FirstValues.Count;
            results.TotalAvailableRows = results.FirstValues.Count;
            results.UnrecognizedFields = query.UnrecognizedSelectFields;
            results.FieldsLoaded = query.ValidSelectFields;

            return results;
        }

        private static SafeFetchResults<T> InternalSafeQuery<T>(ISafeFetchQueryBuilder builder, IDbConnectionFactory dbConnectionFactory, SafeFetchQuery query, int start_index, int max_results, int? query_timeout)
        {
            SafeFetchResults<T> results = new SafeFetchResults<T>();
            results.SortInfos = query.Sort;

            using(Dap dap = new Dap(dbConnectionFactory))
            {
                // First turn this filter into a safe list of values
                SafeFilterParser sfp = new SafeFilterParser();
                sfp.Parse(query.Filter, typeof(T), query.Sort, GetDbType(dap.Connection));

                string fullQuery = builder.BuildSelectQuery(query.ToSelectString(), query.Table, sfp.Filter, sfp.OrderBy);

                // Now query the database and retrieve the object
                List<T> allResults = (List<T>)dap.Query<T>(fullQuery, sfp.SqlParams, null, true, query_timeout ?? DefaultDatabaseTimeout, System.Data.CommandType.Text);
                IEnumerable<T> partialResults = allResults.Skip(start_index);
                if (max_results > 0)
                {
                    partialResults = partialResults.Take(max_results);
                }

                results.Values = partialResults.ToList();

                results.StartIndex = start_index;
                results.EndIndex = start_index + results.Values.Count;
                results.TotalAvailableRows = allResults.Count;
                results.UnrecognizedFields = query.UnrecognizedSelectFields;
                results.FieldsLoaded = query.ValidSelectFields;
            }

            return results;
        }

        /// <summary>
        /// Internal function for parsing a "sort by" string
        /// </summary>
        /// <param name="orderby_and_direction_string"></param>
        /// <returns></returns>
        internal static List<SortInfo> ParseSortBy(string orderby_and_direction_string)
        {
            List<SortInfo> list = new List<SortInfo>();

            // Did the user give a sort string?  If so, break it apart by commas
            if (!String.IsNullOrEmpty(orderby_and_direction_string))
            {
                foreach (var s in orderby_and_direction_string.Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries))
                {
                    string[] order_items = s.Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
                    if (order_items.Length == 2)
                    {
                        if (order_items[1].StartsWith("DESC", StringComparison.CurrentCultureIgnoreCase))
                        {
                            list.Add(new SortInfo() { Fieldname = order_items[0], Direction = SortDirection.Descending });
                        }
                        else if (order_items[1].StartsWith("ASC", StringComparison.CurrentCultureIgnoreCase))
                        {
                            list.Add(new SortInfo() { Fieldname = order_items[0], Direction = SortDirection.Ascending });
                        }
                        else
                        {
                            throw new Exception(String.Format("Unrecognized sort - expected ASC or DESC but found '{0}'", order_items[1]));
                        }

                        // Append this to the sort criteria
                    }
                    else
                    {
                        list.Add(new SortInfo() { Fieldname = order_items[0], Direction = SortDirection.Ascending });
                    }
                }
            }
            return list;
        }

        /// <summary>
        /// Use SQL-Injection safe deleting with a filter
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="dap"></param>
        /// <param name="filter"></param>
        /// <param name="table_name"></param>
        /// <returns></returns>
        internal static long InternalSafeDelete<T>(IDbConnectionFactory dbConnectionFactory, string filter, string table_name) // List<T>
        {
            using(Dap dap = new Dap(dbConnectionFactory))
            {
                // First turn this filter into a safe list of values
                SafeFilterParser sfp = new SafeFilterParser();
                sfp.Parse(filter, typeof(T), null, GetDbType(dap.Connection));

                string query = "DELETE FROM " + table_name + " WHERE " + sfp.Filter;

                // Return number of rows affected
                return dap.Execute(query, sfp.SqlParams);    
            }            
        }

        private static SafeFilterParser.DatabaseType GetDbType(IDbConnection connection)
        {
            if (connection is NpgsqlConnection)
                return SafeFilterParser.DatabaseType.Postgres;

            return SafeFilterParser.DatabaseType.SqlServer;
        }

        private static SafeFetchQuery ToSafeFetchQuery(IDatabaseColumnTranslator translator, string filter, string fieldsToLoad, string table_name, string orderby_and_direction_string)
        {
            SafeFetchQuery query = new SafeFetchQuery();
            query.Table = table_name;
            query.Filter = filter;
            query.Sort = ParseSortBy(orderby_and_direction_string);

            // First check the field are from valid entity fields
            if (!string.IsNullOrEmpty(fieldsToLoad) && !fieldsToLoad.Equals("*"))
            {
                string[] fieldNames = fieldsToLoad.Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);
                foreach (var fieldName in fieldNames.Select(x => x.Trim()))
                {
                    if (fieldName == "*") continue;
                    string dbName = translator.ApiNameToDatabaseColumn(fieldName);
                    if (dbName == null)
                    {
                        query.UnrecognizedSelectFields.Add(fieldName);
                    }
                    else
                    {
                        query.ValidSelectFields.Add(dbName);
                    }
                }
            }

            if (query.ValidSelectFields.Count == 0 || string.IsNullOrEmpty(fieldsToLoad) || fieldsToLoad == "*")
            {
                query.ValidSelectFields.Add("*");
            }

            return query;
        }
    }

    #region Sort information
    public class SortInfo
    {
        public string Fieldname;
        public SortDirection Direction;
    }
    #endregion

    #region SafeFetchQuery
    internal class SafeFetchQuery
    {
        public List<string> ValidSelectFields = new List<string>();
        public List<string> UnrecognizedSelectFields = new List<string>();
        public string Table;
        public string Filter;
        public List<SortInfo> Sort = new List<SortInfo>();

        public string ToSelectString()
        {
            return string.Join(",", ValidSelectFields);
        }
    }
    #endregion

    #region Combination string/type class
    public class SafeFilterInfo
    {
        public string Fieldname;
        public Type Fieldtype;
    }
    #endregion

    #region Filter Parsing
    /// <summary>
    /// Filter parser class that analyzes a filter against a reflected object to validate the criteria
    /// </summary>
    public class SafeFilterParser
    {
        #region Public Properties
        /// <summary>
        /// This is the SQL Filer you should execute.
        /// </summary>
        public string Filter { get; private set; }

        public string OrderBy { get; private set; }

        /// <summary>
        /// This is the SQL Parameter list you should use.
        /// </summary>
        public DynamicParameters SqlParams
        {
            get
            {
                return _params;
            }
            set
            {
                _params = value;
            }
        }

        /// <summary>
        /// This is a list of SqlClient style parameters you can use
        /// </summary>
        public List<SqlParameter> SqlClientParams
        {
            get
            {
                return _sql_params;
            }
        }
        #endregion

        #region Private Variables
        private List<string> SAFE_OPERATIONS = new List<string>(new string[] { "=", ">", ">=", "<>", "!=", "<", "<=", "BETWEEN", "IN", "LIKE", "IS" });

        private List<string> _tokens = null;
        private int _param_num = 1;
        private List<SqlParameter> _sql_params;
        private DynamicParameters _params;
        private StringBuilder _sql = new StringBuilder();
        #endregion

        public void Parse(string filter, Type entity_type, List<SortInfo> order_by, DatabaseType databaseType)
        {
            List<SafeFilterInfo> list = new List<SafeFilterInfo>();
            PropertyInfo[] pilist = entity_type.GetProperties();
            foreach (var pi in pilist)
            {
                list.Add(new SafeFilterInfo { Fieldname = pi.Name, Fieldtype = pi.PropertyType });
            }
            Parse(filter, list.ToArray(), order_by, databaseType);
        }

        public void Parse(string filter, SafeFilterInfo[] safe_fields_list, List<SortInfo> order_by, DatabaseType databaseType)
        {
            if (string.IsNullOrEmpty(filter))
            {
                return;
            }

            _sql = new StringBuilder();

            // First parse the incoming filter into tokens
            SqlParams = new DynamicParameters();
            _sql_params = new List<SqlParameter>();
            _tokens = GenerateTokens(filter);

            // While we have tokens
            while (_tokens.Count > 0)
            {

                // Consume one token - this is the field
                string fieldname = NextToken();

                // Allow the user to put as many connectors in as they like.  Connectors can't cause the query to be sql-injection-vulnerable.
                while (fieldname == ")" || fieldname == "(" || String.Equals(fieldname, "AND", StringComparison.CurrentCultureIgnoreCase) || String.Equals(fieldname, "OR", StringComparison.CurrentCultureIgnoreCase))
                {
                    _sql.Append(" ");
                    _sql.Append(fieldname);
                    _sql.Append(" ");
                    if (_tokens.Count == 0)
                    {
                        fieldname = null;
                        break;
                    }
                    fieldname = NextToken();
                }

                // If fieldname comes up null, we're done
                if (fieldname == null) break;

                // Is this field in the approved list?
                Type fieldtype = null;
                foreach (var pi in safe_fields_list)
                {
                    if(databaseType == DatabaseType.Postgres)
                    {
                        // case insensitive compare for postgres
                        if (string.Equals(pi.Fieldname, fieldname, StringComparison.OrdinalIgnoreCase))
                        {
                            fieldtype = pi.Fieldtype;
                            fieldname = pi.Fieldname; // use db version so it'll work when quoted below
                            break;
                        }
                    }
                    else
                    {
                        if (pi.Fieldname == fieldname)
                        {
                            fieldtype = pi.Fieldtype;
                            break;
                        }
                    }
                }
                if (fieldtype == null)
                {
                    throw new Exception(String.Format("The field name {0} is not recognized.", fieldname));
                }

                switch (databaseType)
                {
                    case DatabaseType.SqlServer:
                        _sql.Append(string.Format("[" + fieldname + "]"));
                        break;
                    case DatabaseType.Mysql:
                        _sql.Append(string.Format("`" + fieldname + "`"));
                        break;
                    case DatabaseType.Postgres:
                        _sql.Append(string.Format("\"" + fieldname + "\""));
                        break;
                    default:
                        throw new ArgumentOutOfRangeException("databaseType", databaseType, null);
                }

                _sql.Append(" ");

                // Next is the operation
                // ToUpper to remove case-sensitivity
                string op = NextToken().ToUpper();
                if (!SAFE_OPERATIONS.Contains(op))
                {
                    throw new Exception(String.Format("The operation {0} is not recognized.", op));
                }
                _sql.Append(op);
                _sql.Append(" ");

                // Depending on the field type & op, let's add some parameters
                if (op == "BETWEEN")
                {
                    AddParameter(fieldtype);
                    _sql.Append(" AND ");
                    AddParameter(fieldtype);

                    // In a list of values
                }
                else if (op == "IN")
                {
                    Expect("(");
                    _sql.Append("(");
                    while (true)
                    {
                        AddParameter(fieldtype);
                        string comma_or_paren = NextToken();
                        if (comma_or_paren == ")") break;
                        if (comma_or_paren != ",")
                        {
                            throw new Exception(String.Format("Expected ','.  Found '{0}'.", comma_or_paren));
                        }
                        _sql.Append(", ");
                    }
                    _sql.Append(")");

                    // Support for "IS NULL"
                }
                else if (op == "IS")
                {
                    Expect("NULL");
                    _sql.Append(" NULL ");

                    // Single value
                }
                else
                {
                    AddParameter(fieldtype);
                }
            }

            // Did they specify a sort?
            if (order_by != null && order_by.Count > 0)
            {
                StringBuilder orderByBuilder = new StringBuilder();
                orderByBuilder.Append(" ORDER BY ");
                foreach (var o in order_by)
                {
                    foreach (var pi in safe_fields_list)
                    {
                        if (String.Equals(pi.Fieldname, o.Fieldname, StringComparison.CurrentCultureIgnoreCase))
                        {
                            orderByBuilder.Append(pi.Fieldname);
                            if (o.Direction == SortDirection.Ascending)
                            {
                                orderByBuilder.Append(" ASC, ");
                            }
                            else
                            {
                                orderByBuilder.Append(" DESC, ");
                            }
                        }
                    }
                }

                // Remove the last comma
                OrderBy = orderByBuilder.ToString(0, orderByBuilder.Length - 2);
            }

            // Here's your SQL
            Filter = _sql.ToString();
        }

        private void Expect(string expected_token)
        {
            string actual = NextToken();
            if (!String.Equals(expected_token, actual))
            {
                throw new Exception(String.Format("Expected '{0}'.  Found '{1}'.", expected_token, actual));
            }
        }

        #region Safe Tokenization Function
        public static List<string> GenerateTokens(string filter)
        {
            List<string> tokens = new List<string>();
            StringBuilder sb = new StringBuilder();

            // Go through each character
            int i = 0;
            bool in_string = false;
            bool in_token = false;
            bool in_quotes = false;
            List<char> token_chars_lst = new List<char> { '=', '>', '<', '(', ')', ',', '!' };
            while (i < filter.Length)
            {
                char c = filter[i];

                // Whitespace characters always end a token)
                if (Char.IsWhiteSpace(c))
                {

                    // ...Unless they're in quotes (ie as part of value)
                    if (in_quotes)
                    {
                        sb.Append(c);
                    }
                    else if (in_token)
                    {
                        tokens.Add(sb.ToString());
                        sb.Length = 0;
                        in_token = false;
                        in_string = false;
                    }
                }

                // If this is one of the special chars (>, =, etc) end token and count char as its own token
                if (CharIsListed(c, token_chars_lst))
                {

                    // Signify end of the token preceding it
                    if (in_token)
                    {
                        tokens.Add(sb.ToString());
                        in_token = false;
                    }

                    // If the token is actually part of a >= or <= block, add the equal sign to it.
                    string s = c.ToString();
                    if (c == '!')
                    {
                        if (filter[i + 1] == '=')
                        {
                            s += filter[i + 1];
                            i++;
                        }
                    }
                    if (c == '<')
                    {
                        if (filter[i + 1] == '>')
                        {
                            s += filter[i + 1];
                            i++;
                        }
                    }
                    if (c == '>' || c == '<')
                    {
                        if (filter[i + 1] == '=')
                        {
                            s += filter[i + 1];
                            i++;
                        }
                    }

                    tokens.Add(s);
                    sb.Length = 0;
                }

                // Apostrophes trigger string mode
                if (c == '\'')
                {
                    while (i < filter.Length)
                    {
                        i++;
                        c = filter[i];
                        if (c == '\'')
                        {

                            // If there's a double apostrophe, treat it as a single one
                            if ((i + 1 <= filter.Length - 1) && (filter[i + 1] == '\''))
                            {
                                sb.Append('\'');
                                i++;
                            }
                            else
                            {
                                tokens.Add(sb.ToString());
                                sb.Length = 0;
                                in_string = false;
                                in_quotes = false;
                                break;
                            }

                        }
                        else
                        {
                            sb.Append(c);
                        }
                    }

                    // If the string failed to end properly, throw an error
                    if (in_string)
                    {
                        throw new Exception("Non-terminated string in filter.");
                    }

                    // Normal characters just get added to the token
                }
                else
                {
                    if (Char.IsWhiteSpace(c) == false && !CharIsListed(c, token_chars_lst))
                    {
                        sb.Append(c);
                        in_token = true;
                    }
                }

                // Move to the next char
                i++;
            }

            // Allow strings to end normally
            if (in_token)
            {
                tokens.Add(sb.ToString());
            }

            // Here's your tokenized list
            return tokens;
        }

        //Checks to see if char is in list
        private static bool CharIsListed(char c, List<char> token_chars)
        {
            // -1 means variable is not in list
            if (token_chars.IndexOf(c) != -1)
            {
                return true;
            }
            else
            {
                return false;
            }
        }
        #endregion

        #region Helper Functions
        private void AddParameter(Type fieldtype)
        {
            if (_param_num > 1999) throw new Exception("Maximum 1999 parameters.");

            // Figure out what parameter number we are
            string pname = "@p" + _param_num.ToString();
            _param_num++;
            _sql.Append(pname);
            _sql.Append(" ");
            string token = NextToken();

            // Attempt to cast this item to the specified type
            object pvalue;
            if (fieldtype.IsGenericType && fieldtype.GetGenericTypeDefinition() == typeof(Nullable<>))
            {
                if (String.IsNullOrEmpty(token))
                    pvalue = null;
                else
                    pvalue = Convert.ChangeType(token, fieldtype.GetGenericArguments()[0]);
            }
            else if(fieldtype == typeof(Guid))
            {
                pvalue = Guid.Parse(token);
            }
            else
            {
                pvalue = Convert.ChangeType(token, fieldtype);
            }


            // Put this into an SQL Parameter list
            _params.Add(pname, pvalue);
            _sql_params.Add(new SqlParameter(pname, pvalue));
        }

        private string NextToken()
        {
            string v = _tokens[0];
            _tokens.RemoveAt(0);
            return v;
        }
        #endregion

        public enum DatabaseType
        {
            SqlServer = 0,
            Mysql = 1,
            Postgres = 2
        }
    }
    #endregion
}

]]>
    </BaseContent>
</PatternFile>
